<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="2014 年 6 月號" />
  <title>程式人雜誌</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/pmag.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
   <h1><a href="https://www.facebook.com/groups/programmerMagazine">程式人雜誌</a> <sub> --  <a href="https://dl.dropbox.com/u/101584453/pmag/201403/htm/home.html">2014 年 6 月號</a> (開放公益出版品)</sub></h1>
</div>
<div id="content">
<div id="header">
<h1 class="title"><a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌</a></h1>
<h2 class="author">2014 年 6 月號</h2>
<h3 class="date">本期焦點：圖形搜尋</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#前言">前言</a><ul>
<li><a href="#編輯小語">編輯小語</a></li>
<li><a href="#授權聲明">授權聲明</a></li>
</ul></li>
<li><a href="#本期焦點">本期焦點</a><ul>
<li><a href="#圖形搜尋簡介">圖形搜尋簡介</a></li>
<li><a href="#深度與廣度搜尋法實作---使用-javascriptnode.js-實作">深度與廣度搜尋法實作 - 使用 JavaScript+Node.js 實作</a></li>
<li><a href="#以深度優先搜尋解決老鼠走迷宮問題---使用-javascriptnode.js-實作">以深度優先搜尋解決老鼠走迷宮問題 - 使用 JavaScript+Node.js 實作</a></li>
<li><a href="#以廣度優先搜尋解決拼圖問題---使用-javascriptnode.js-實作">以廣度優先搜尋解決拼圖問題 - 使用 JavaScript+Node.js 實作</a></li>
</ul></li>
<li><a href="#程式人文集">程式人文集</a><ul>
<li><a href="#從-arduino-到-avr-晶片1----avr-晶片與-io-ports-範例-作者cooper-maa">從 Arduino 到 AVR 晶片(1) -- AVR 晶片與 IO ports 範例 (作者：Cooper Maa)</a></li>
<li><a href="#符式協會論文文件編輯入門教學1-作業環境準備-作者鄧淵元">符式協會論文文件編輯入門教學(1) – 作業環境準備 (作者：鄧淵元)</a></li>
<li><a href="#從-rs-232-偷電的方法-作者bridan">從 RS-232 偷電的方法 (作者：Bridan)</a></li>
<li><a href="#visual-basic-6.0實作簡易小算盤-作者廖憲得-0xde">Visual Basic 6.0:實作簡易小算盤 (作者：廖憲得 0xde)</a></li>
</ul></li>
<li><a href="#雜誌訊息">雜誌訊息</a><ul>
<li><a href="#讀者訂閱">讀者訂閱</a></li>
<li><a href="#投稿須知">投稿須知</a></li>
<li><a href="#參與編輯">參與編輯</a></li>
<li><a href="#公益資訊">公益資訊</a></li>
</ul></li>
</ul>
</div>
<h1 id="前言"><a href="#前言">前言</a></h1>
<h2 id="編輯小語"><a href="#編輯小語">編輯小語</a></h2>
<p>在本期的「程式人雜誌」中，聚焦的主題是「圖形搜尋」，包含深度優先 DFS、廣度優先 BFS 與最佳優先搜尋等等！</p>
<p>另外、Arduino 系列雖然告一段落，但是 Cooper Maa 探索 Arduino 背後 AVR 晶片的文章「從 Arduino 到 AVR 晶片(1) -- AVR 晶片與 IO ports 範例」則讓我們能夠初步理解 Arduino 的設計原理，以及和 AVR 晶片之間的關係。</p>
<p>接著、鄧淵元先生的「符式協會論文文件編輯入門教學(1) – 作業環境準備」，介紹了如何採用和「程式人雜誌」編撰相同的手法，編寫電子書與論文的方法。這篇文章補足了之前我們沒介紹的很多部份，並且加了不少新的內容，很適合想學習電子書編撰的朋友們閱讀。</p>
<p>另外、我們還有 0xde 的 「Visual Basic 6.0:實作簡易小算盤」與 Bridan 的「從 RS-232 偷電的方法」等文章，希望讀者們會喜歡。</p>
<p>---- （程式人雜誌編輯 - 陳鍾誠）</p>
<h2 id="授權聲明"><a href="#授權聲明">授權聲明</a></h2>
<p>本雜誌許多資料修改自維基百科，採用 創作共用：<a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 授權，若您想要修改本書產生衍生著作時，至少應該遵守下列授權條件：</p>
<ol style="list-style-type: decimal">
<li>標示原作者姓名 (包含該文章作者，若有來自維基百科的部份也請一併標示)。</li>
<li>採用 創作共用：<a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 的方式公開衍生著作。</li>
</ol>
<p>另外、當本雜誌中有文章或素材並非採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 時，將會在該文章或素材後面標示其授權，此時該文章將以該標示的方式授權釋出，請修改者注意這些授權標示，以避免產生侵權糾紛。</p>
<p>例如有些文章可能不希望被作為「商業性使用」，此時就可能會採用創作共用：<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/tw/">姓名標示、非商業性、相同方式分享</a> 的授權，此時您就不應當將該文章用於商業用途上。</p>
<p>最後、懇請勿移除公益捐贈的相關描述，以便讓愛心得以持續散播！</p>
<h1 id="本期焦點"><a href="#本期焦點">本期焦點</a></h1>
<h2 id="圖形搜尋簡介"><a href="#圖形搜尋簡介">圖形搜尋簡介</a></h2>
<h3 id="簡介"><a href="#簡介">簡介</a></h3>
<p>在離散數學、演算法與人工智慧的領域，很多問題可以表示為「節點與連線所形成的圖形」，一個程式要解決某問題其實是在這個圖形裏把目標節點給找出來，於是問題求解就簡化成了圖形的搜尋，我們只要把解答給「找出來」就行了。</p>
<p>圖形搜尋的方法大致可以分為「深度優先搜尋 (Depth-First Search, DFS)、廣度優先搜尋 (Breath-First Search, BFS)、最佳優先搜尋 (Best-First Search, BestFS) 等三類。</p>
<p>然後針對最佳優先搜尋的部份，還有一種具有理論背景，且較為強大好用的 A* 搜尋法可採用。</p>
<h3 id="圖形的表達"><a href="#圖形的表達">圖形的表達</a></h3>
<p>圖形是由節點 (node) 與連線 (edge) 所組成的。舉例而言，以下是一個包含六個節點與十條連線的簡單圖形。</p>
<div class="figure">
<img src="../img/graphSearch.jpg" alt="圖、圖形 Graph 的範例" /><p class="caption">圖、圖形 Graph 的範例</p>
</div>
<h3 id="深度優先搜尋"><a href="#深度優先搜尋">深度優先搜尋</a></h3>
<p>所謂的「深度優先搜尋」 (Depth-First Search, DFS)，就是一直往尚未訪問過的第一個鄰居節點走去的一種方法，這種方法可以採用程式設計中的「遞迴技巧」完成，以下是深度搜尋的演算法：</p>
<pre><code>Algorithm DFS(graph, node) {  // 深度優先搜尋，graph : 圖形, node:節點
  if (node.visited) return;     // 如果已訪問過，就不再訪問
  node.visited = 1;             //   並設定為已訪問
  foreach (neighbor of node)  // 對於每個鄰居
    DFS(graph, neighbor);     //   逐一進行深度優先搜尋的訪問。
end</code></pre>
<p>您可以看到上述的演算法中，我們單純採用遞迴的方式，就可以輕易的完成整個 DFS 演算法。</p>
<p>當然、實作為程式的時候，會稍微複雜一點，以下是使用 Javascript 的實作方式：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">dfs</span>(g, node) { <span class="co">// 深度優先搜尋</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> !=<span class="dv">0</span>) <span class="kw">return</span>;   <span class="co">// 如果已訪問過，就不再訪問</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);       <span class="co">// 否則、印出節點</span>
  g[node].<span class="fu">v</span> = <span class="dv">1</span>;              <span class="co">//   並設定為已訪問</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>;  <span class="co">// 取出鄰居節點</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) {  <span class="co">// 對於每個鄰居</span>
    <span class="fu">dfs</span>(g, neighbors[i]);     <span class="co">//   逐一進行訪問</span>
  }
}</code></pre>
<p>針對上述的範例圖形，若採用深度優先搜尋，其結果可能如下所示 (圖中紅色的數字代表訪問順序)</p>
<div class="figure">
<img src="../img/dfs.jpg" alt="圖、深度優先搜尋的順序" /><p class="caption">圖、深度優先搜尋的順序</p>
</div>
<h3 id="廣度優先搜尋"><a href="#廣度優先搜尋">廣度優先搜尋</a></h3>
<p>雖然深度優先搜尋可以搜尋整個圖形，但是卻很可能繞了很久才找到目標，於是從起點到目標可能會花費很久的時間 (或說路徑長度過長)。</p>
<p>如果我們想找出到達目標最少的步驟，那麼就可以採用「廣度優先搜尋」 (Breath-First Search, BFS) 的方式。</p>
<p>廣度優先搜尋 BFS 是從一個節點開始，將每個鄰居節點都一層一層的拜訪下去，深度最淺的節點會優先被拜訪的方式。</p>
<p>舉例而言，針對上述的圖形範例，若採用「廣度優先搜尋 BFS 」的方式，那麼拜訪順序將會如下所示：</p>
<div class="figure">
<img src="../img/bfs.jpg" alt="圖、廣度優先搜尋的順序" /><p class="caption">圖、廣度優先搜尋的順序</p>
</div>
<p>要能用程式進行廣度優先搜尋，必須採用「先進先出」(First-in First-Out, FIFO) 的方式管理節點，因此通常在「廣度優先搜尋」裏會有個佇列 (queue) 結構，以下是 BFS 的演算法：</p>
<pre><code>Algorithm BFS(graph, queue)
  if queue.empty() return;
    node = queue.dequeue();
    if (!node.visited)
      node.visited = true
    else
      return;
    foreach (neighbor of node)
      if (!neighbor.visited)
          queue.push(neighbor)
end</code></pre>
<p>以下是使用 Javascript 的 BFS 程式實作片段：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">bfs</span>(g, q) { <span class="co">// 廣度優先搜尋</span>
  <span class="kw">if</span> (<span class="ot">q</span>.<span class="fu">length</span> == <span class="dv">0</span>) <span class="kw">return</span>; <span class="co">// 如果 queue 已空，則返回。</span>
  <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否則、取出 queue 的第一個節點。</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> == <span class="dv">0</span>)        <span class="co">// 如果該節點尚未拜訪過。</span>
    g[node].<span class="fu">v</span> = <span class="dv">1</span>;           <span class="co">//   標示為已拜訪</span>
  <span class="kw">else</span>                       <span class="co">// 否則 (已訪問過)</span>
    <span class="kw">return</span>;                  <span class="co">//   不繼續搜尋，直接返回。</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);      <span class="co">// 印出節點</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>; <span class="co">// 取出鄰居。</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 對於每個鄰居</span>
    <span class="kw">var</span> n = neighbors[i];
    <span class="kw">if</span> (!g[n].<span class="fu">visited</span>)       <span class="co">// 假如該鄰居還沒被拜訪過</span>
      <span class="ot">q</span>.<span class="fu">push</span>(n);             <span class="co">//   就放入 queue 中</span>
  }
  <span class="fu">bfs</span>(g, q);
}</code></pre>
<h3 id="最佳優先搜尋"><a href="#最佳優先搜尋">最佳優先搜尋</a></h3>
<p>但是、上述兩個方法其實都還不夠好，深度搜尋會猛衝亂衝，而廣度搜尋則會耗費太多的記憶體，並且沒有效率，無法很快的找到目標點。</p>
<p>假如我們能夠知道哪些點距離目標點最近，也就是哪些點比較好的話，那就能採用「最佳優先搜尋 (Best-First Search) 的方式來搜尋了。</p>
<p>最佳優先搜尋的實作方法與廣度優先搜尋類似，但是並不採用佇列 (queue) ，而是採用一種根據優先程度排序的結構，每次都取出最好的那個繼續進行搜尋。</p>
<p>但是、節點的好壞通常很難評估，單純採用某種距離去評估往往會過度簡化問題，這點往往是最佳優先搜尋的困難之所在。</p>
<p>還好、有時我們不需要非常精確的評估，只要問題符合 <img src="../timg/9c5e6fefcb1f.jpg" /> 這樣的單調 (monotone) 特性，就可以使用 <code>A*</code> 演算法來進行較快速的搜尋，這種方法比廣度優先搜尋通常快很多，因為 <code>A*</code> 不會搜尋所有節點，而是有系統的朝著整體較好的方向前進，這種方法在電腦遊戲 (Game) 上常被用在 NPC (非人類角色) 的智慧型搜尋行為設計上面，是人工智慧搜尋方法中較強大的一種。</p>
<h3 id="參考文獻"><a href="#參考文獻">參考文獻</a></h3>
<ul>
<li><a href="http://en.wikipedia.org/wiki/A*_search_algorithm">Wikipedia:A* search algorithm</a></li>
<li><a href="http://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%AF%BB%E7%AE%97%E6%B3%95">維基百科:A*搜尋演算法</a></li>
<li><a href="http://zh.wikipedia.org/zh-tw/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">維基百科:廣度優先搜索</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">維基百科:深度優先搜索</a></li>
</ul>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org/">維基百科</a>，採用創作共用的 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 授權】</p>
<h2 id="深度與廣度搜尋法實作---使用-javascriptnode.js-實作"><a href="#深度與廣度搜尋法實作---使用-javascriptnode.js-實作">深度與廣度搜尋法實作 - 使用 JavaScript+Node.js 實作</a></h2>
<h3 id="簡介-1"><a href="#簡介-1">簡介</a></h3>
<p>為了進一步理解深度優先搜尋 (Depth-First Search) 與廣度優先搜尋 (Breath-First Search) ，我們將在本文中採用 JavaScript 實作這兩個圖形搜尋算法，並且在 node.js 平台上進行測試。</p>
<p>在以下程式中，變數 g 代表下列圖形，而程式中的 dfs() 函數代表深度優先搜尋算法，bfs() 函數代表廣度優先搜尋算法。</p>
<div class="figure">
<img src="../img/graphSearch.jpg" alt="圖、圖形 Graph 的範例" /><p class="caption">圖、圖形 Graph 的範例</p>
</div>
<h3 id="程式實作"><a href="#程式實作">程式實作</a></h3>
<p>檔案：graphSearch.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);

<span class="kw">var</span> printf = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="ot">process</span>.<span class="ot">stdout</span>.<span class="fu">write</span>(<span class="ot">util</span>.<span class="ot">format</span>.<span class="fu">apply</span>(<span class="kw">null</span>, arguments)); 
}

<span class="kw">function</span> <span class="fu">enqueue</span>(a, o) { <span class="ot">a</span>.<span class="fu">push</span>(o); }
<span class="kw">function</span> <span class="fu">dequeue</span>(a) { <span class="kw">return</span> <span class="ot">a</span>.<span class="fu">shift</span>(); }

<span class="kw">var</span> g = {            <span class="co">// graph: 被搜尋的網路</span>
  <span class="dv">1</span>: {<span class="dt">n</span>:[<span class="dv">2</span>,<span class="dv">5</span>], <span class="dt">v</span>:<span class="dv">0</span>}, <span class="co">// n: neighbor (鄰居), v: visited (是否被訪問過)</span>
  <span class="dv">2</span>: {<span class="dt">n</span>:[<span class="dv">3</span>,<span class="dv">4</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">3</span>: {<span class="dt">n</span>:[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">4</span>: {<span class="dt">n</span>:[<span class="dv">5</span>,<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">5</span>: {<span class="dt">n</span>:[<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">6</span>: {<span class="dt">n</span>:[], <span class="dt">v</span>:<span class="dv">0</span>}
};

<span class="kw">function</span> <span class="fu">init</span>(g) { <span class="co">// 初始化、設定 visited 為 0</span>
  <span class="kw">for</span> (i <span class="kw">in</span> g) g[i].<span class="fu">v</span> = <span class="dv">0</span>;
}

<span class="kw">function</span> <span class="fu">dfs</span>(g, node) { <span class="co">// 深度優先搜尋</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> !=<span class="dv">0</span>) <span class="kw">return</span>;   <span class="co">// 如果已訪問過，就不再訪問</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);       <span class="co">// 否則、印出節點</span>
  g[node].<span class="fu">v</span> = <span class="dv">1</span>;              <span class="co">//   並設定為已訪問</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>;  <span class="co">// 取出鄰居節點</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) {  <span class="co">// 對於每個鄰居</span>
    <span class="fu">dfs</span>(g, neighbors[i]);     <span class="co">//   逐一進行訪問</span>
  }
}

<span class="kw">var</span> queue=[<span class="dv">1</span>];            <span class="co">// BFS 用的 queue, 起始點為 1。</span>

<span class="kw">function</span> <span class="fu">bfs</span>(g, q) { <span class="co">// 廣度優先搜尋</span>
  <span class="kw">if</span> (<span class="ot">q</span>.<span class="fu">length</span> == <span class="dv">0</span>) <span class="kw">return</span>; <span class="co">// 如果 queue 已空，則返回。</span>
  <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否則、取出 queue 的第一個節點。</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> == <span class="dv">0</span>)        <span class="co">// 如果該節點尚未拜訪過。</span>
    g[node].<span class="fu">v</span> = <span class="dv">1</span>;           <span class="co">//   標示為已拜訪</span>
  <span class="kw">else</span>                       <span class="co">// 否則 (已訪問過)</span>
    <span class="kw">return</span>;                  <span class="co">//   不繼續搜尋，直接返回。</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);      <span class="co">// 印出節點</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>; <span class="co">// 取出鄰居。</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 對於每個鄰居</span>
    <span class="kw">var</span> n = neighbors[i];
    <span class="kw">if</span> (!g[n].<span class="fu">visited</span>)       <span class="co">// 假如該鄰居還沒被拜訪過</span>
      <span class="ot">q</span>.<span class="fu">push</span>(n);             <span class="co">//   就放入 queue 中</span>
  }
  <span class="fu">bfs</span>(g, q);
}

<span class="fu">printf</span>(<span class="st">&quot;dfs:&quot;</span>); <span class="fu">init</span>(g); <span class="fu">dfs</span>(g, <span class="dv">1</span>); <span class="fu">printf</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);     <span class="co">// 呼叫深度優先搜尋。</span>
<span class="fu">printf</span>(<span class="st">&quot;bfs:&quot;</span>); <span class="fu">init</span>(g); <span class="fu">bfs</span>(g, queue); <span class="fu">printf</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="co">// 呼叫廣度優先搜尋。</span></code></pre>
<h3 id="執行結果"><a href="#執行結果">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node graphSearch.js
dfs:1=&gt;2=&gt;3=&gt;4=&gt;5=&gt;6=&gt;
bfs:1=&gt;2=&gt;5=&gt;3=&gt;4=&gt;6=&gt;</code></pre>
<h3 id="結語"><a href="#結語">結語</a></h3>
<p>從以上範例您可以看到 BFS 與 DFS 之差異，不過我們沒有為節點加入好壞的評估函數，因此沒有實作最佳優先搜尋，或許讀者可以自行嘗試修改看看。</p>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org/">維基百科</a>，採用創作共用的 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 授權】</p>
<h2 id="以深度優先搜尋解決老鼠走迷宮問題---使用-javascriptnode.js-實作"><a href="#以深度優先搜尋解決老鼠走迷宮問題---使用-javascriptnode.js-實作">以深度優先搜尋解決老鼠走迷宮問題 - 使用 JavaScript+Node.js 實作</a></h2>
<h3 id="前言-1"><a href="#前言-1">前言</a></h3>
<p>雖然深度優先搜尋 (DFS) 與廣度優先搜尋 (BFS) 等演算法通常是用在「圖形」這種結構上的，不過「圖形」的結構倒是不一定要真實且完整的表達出來，在很多人工智慧的問題上，我們不會看到完整的「圖形結構」，只會看到某個節點有哪些鄰居節點，然後就可以用 BFS 與 DFS 進行搜尋了。</p>
<p>老鼠走迷宮問題，就是一個可以採用圖形搜尋來解決的經典問題，其中每個節點的鄰居，就是上下左右四個方向，只要沒有被牆給擋住，就可以走到鄰居節點去，因此我們可以採用圖形搜尋的方法來解決迷宮問題，以下是我們的程式實作。</p>
<h3 id="程式實作老鼠走迷宮"><a href="#程式實作老鼠走迷宮">程式實作：老鼠走迷宮</a></h3>
<p>檔案：pathFinder.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

<span class="kw">function</span> <span class="fu">matrixPrint</span>(m) {
  <span class="kw">for</span>(<span class="kw">var</span> i=<span class="dv">0</span>;i&lt;<span class="ot">m</span>.<span class="fu">length</span>;i++)
    <span class="fu">log</span>(m[i]);
}

<span class="kw">function</span> <span class="fu">strset</span>(s, i, c) {
  <span class="kw">return</span> <span class="ot">s</span>.<span class="fu">substr</span>(<span class="dv">0</span>, i) + c + <span class="ot">s</span>.<span class="fu">substr</span>(i<span class="dv">+1</span>);
}

<span class="kw">function</span> <span class="fu">findPath</span>(m, x, y) {
  <span class="fu">log</span>(<span class="st">&quot;=========================&quot;</span>);
  <span class="fu">log</span>(<span class="st">&quot;x=&quot;</span>+x+<span class="st">&quot; y=&quot;</span>+y);
  <span class="fu">matrixPrint</span>(m);
  <span class="kw">if</span> (x&gt;=<span class="dv">6</span>||y&gt;=<span class="dv">8</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;*&#39;</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;+&#39;</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39; &#39;</span>) m[x] = <span class="fu">strset</span>(m[x], y, <span class="st">&#39;.&#39;</span>);
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;.&#39;</span> &amp;&amp; (x == <span class="dv">5</span> || y==<span class="dv">7</span>)) 
    <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span> (y&lt;<span class="dv">7</span>&amp;&amp;m[x][y<span class="dv">+1</span>]==<span class="st">&#39; &#39;</span>) <span class="co">//向右</span>
    <span class="kw">if</span> (<span class="fu">findPath</span>(m, x,y<span class="dv">+1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(x&lt;<span class="dv">5</span>&amp;&amp;m[x<span class="dv">+1</span>][y]==<span class="st">&#39; &#39;</span>) <span class="co">//向下</span>
    <span class="kw">if</span> (<span class="fu">findPath</span>(m, x<span class="dv">+1</span>,y)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(y&gt;<span class="dv">0</span>&amp;&amp;m[x][y<span class="dv">-1</span>]==<span class="st">&#39; &#39;</span>) <span class="co">//向左</span>
    <span class="kw">if</span> (<span class="fu">findPath</span>(m, x,y<span class="dv">-1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(x&gt;<span class="dv">0</span>&amp;&amp;m[x<span class="dv">-1</span>][y]==<span class="st">&#39; &#39;</span>) <span class="co">//向上</span>
    <span class="kw">if</span> (<span class="fu">findPath</span>(m, x<span class="dv">-1</span>,y)) <span class="kw">return</span> <span class="kw">true</span>;
  m[x][y]=<span class="st">&#39;+&#39;</span>;
  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="kw">var</span> m =[<span class="st">&quot;********&quot;</span>, 
        <span class="st">&quot;** * ***&quot;</span>,
        <span class="st">&quot;     ***&quot;</span>,
        <span class="st">&quot;* ******&quot;</span>,
        <span class="st">&quot;*     **&quot;</span>,
        <span class="st">&quot;***** **&quot;</span>];
    
<span class="fu">findPath</span>(m, <span class="dv">2</span>, <span class="dv">0</span>);
<span class="fu">log</span>(<span class="st">&quot;=========================&quot;</span>);
<span class="fu">matrixPrint</span>(m);</code></pre>
<h3 id="執行結果-1"><a href="#執行結果-1">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node pathFinder.js
=========================
x=2 y=0
********
** * ***
     ***
* ******
*     **
***** **
=========================
x=2 y=1
********
** * ***
.    ***
* ******
*     **
***** **
=========================
x=2 y=2
********
** * ***
..   ***
* ******
*     **
***** **
=========================
x=2 y=3
********
** * ***
...  ***
* ******
*     **
***** **
=========================
x=2 y=4
********
** * ***
.... ***
* ******
*     **
***** **
=========================
x=1 y=4
********
** * ***
.....***
* ******
*     **
***** **
=========================
x=1 y=2
********
** *.***
.....***
* ******
*     **
***** **
=========================
x=3 y=1
********
**.*.***
.....***
* ******
*     **
***** **
=========================
x=4 y=1
********
**.*.***
.....***
*.******
*     **
***** **
=========================
x=4 y=2
********
**.*.***
.....***
*.******
*.    **
***** **
=========================
x=4 y=3
********
**.*.***
.....***
*.******
*..   **
***** **
=========================
x=4 y=4
********
**.*.***
.....***
*.******
*...  **
***** **
=========================
x=4 y=5
********
**.*.***
.....***
*.******
*.... **
***** **
=========================
x=5 y=5
********
**.*.***
.....***
*.******
*.....**
***** **
=========================
********
**.*.***
.....***
*.******
*.....**
*****.**</code></pre>
<h3 id="結語-1"><a href="#結語-1">結語</a></h3>
<p>在上面的輸出結果中，<code>*</code> 代表該位置是牆壁，而空格則代表是可以走的路，老鼠走過的地方會放下一個 <code>.</code> 符號，於是您可以看到在上述程式的輸出中，老鼠最後走出了迷宮，完成了任務。</p>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org/">維基百科</a>，採用創作共用的 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 授權】</p>
<h2 id="以廣度優先搜尋解決拼圖問題---使用-javascriptnode.js-實作"><a href="#以廣度優先搜尋解決拼圖問題---使用-javascriptnode.js-實作">以廣度優先搜尋解決拼圖問題 - 使用 JavaScript+Node.js 實作</a></h2>
<h3 id="前言-2"><a href="#前言-2">前言</a></h3>
<p>以下的「拼圖問題」是將一個已經移動打亂過的拼盤，想辦法移動回原本樣子的問題。</p>
<div class="figure">
<img src="../img/puzzle.jpg" alt="圖、本文程式中的拼圖問題" /><p class="caption">圖、本文程式中的拼圖問題</p>
</div>
<p>在以下程式中，我們用一個 3*3 的陣列來代表拼盤，並且用數字 0 來代表其中的空格，因此將方塊 2 移動到空格，其實是用將 0 與 2 兩個數字位置交換所達成的。</p>
<p>透過這樣的資料結構，我們就可以用「廣度優先搜尋」(BFS) 來解決拼圖問題了，以下是我們用 JavaScript 實作，並用 node.js 進行測試的結果。</p>
<h3 id="程式實作拼圖問題"><a href="#程式實作拼圖問題">程式實作：拼圖問題</a></h3>
<p>檔案：puzzleSearch.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);
<span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;
<span class="kw">var</span> up = <span class="dv">1</span>, right=<span class="dv">2</span>, down=<span class="dv">3</span>, left=<span class="dv">4</span>;

<span class="kw">function</span> <span class="fu">enqueue</span>(a, o) { <span class="ot">a</span>.<span class="fu">push</span>(o); }
<span class="kw">function</span> <span class="fu">dequeue</span>(a) { <span class="kw">return</span> <span class="ot">a</span>.<span class="fu">shift</span>(); }
<span class="kw">function</span> <span class="fu">equal</span>(a, b) { <span class="kw">return</span> <span class="ot">JSON</span>.<span class="fu">stringify</span>(a)===<span class="ot">JSON</span>.<span class="fu">stringify</span>(b); }
<span class="kw">function</span> <span class="fu">board2str</span>(b) { <span class="kw">return</span> <span class="ot">b</span>.<span class="fu">join</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>); }

<span class="kw">function</span> <span class="fu">findXY</span>(board, value) {
  <span class="kw">for</span> (<span class="kw">var</span> x=<span class="dv">0</span>; x&lt;<span class="ot">board</span>.<span class="fu">length</span>; x++)
    <span class="kw">for</span> (<span class="kw">var</span> y=<span class="dv">0</span>; y&lt;board[x].<span class="fu">length</span>; y++)
      <span class="kw">if</span> (board[x][y] === value)
        <span class="kw">return</span> {<span class="dt">x</span>:x,<span class="dt">y</span>:y};
  <span class="kw">return</span> <span class="kw">null</span>;
}

<span class="kw">function</span> <span class="fu">boardClone</span>(b) {
  <span class="kw">var</span> nb = [];
  <span class="kw">for</span> (<span class="kw">var</span> x <span class="kw">in</span> b)
    nb[x] = b[x].<span class="fu">slice</span>(<span class="dv">0</span>);
  <span class="kw">return</span> nb;
}

<span class="kw">function</span> <span class="fu">swap</span>(b,x1,y1,x2,y2) {
  x2 = <span class="ot">Math</span>.<span class="fu">round</span>(x2), y2=<span class="ot">Math</span>.<span class="fu">round</span>(y2);
  <span class="kw">if</span> (x2&lt;<span class="dv">0</span> || x2 &gt; <span class="dv">2</span> || y2&lt;<span class="dv">0</span> || y2&gt;<span class="dv">2</span>) 
    <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">var</span> t = b[x1][y1];
  b[x1][y1]=b[x2][y2];
  b[x2][y2]=t;
  <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="kw">function</span> <span class="fu">move</span>(board, dir) {
  <span class="kw">var</span> xy = <span class="fu">findXY</span>(board, <span class="dv">0</span>);
  <span class="kw">var</span> x = <span class="ot">xy</span>.<span class="fu">x</span>, y=<span class="ot">xy</span>.<span class="fu">y</span>;
  <span class="kw">var</span> nboard = <span class="fu">boardClone</span>(board);
  <span class="kw">var</span> s = <span class="kw">false</span>;
  <span class="kw">switch</span> (dir) {
    <span class="kw">case</span> <span class="dt">up</span>:    s=<span class="fu">swap</span>(nboard,x,y,x<span class="dv">-1</span>,y); <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dt">right</span>: s=<span class="fu">swap</span>(nboard,x,y,x,y<span class="dv">+1</span>); <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dt">down</span>:  s=<span class="fu">swap</span>(nboard,x,y,x<span class="dv">+1</span>,y); <span class="kw">break</span>;
    <span class="kw">case</span> <span class="dt">left</span>:  s=<span class="fu">swap</span>(nboard,x,y,x,y<span class="dv">-1</span>); <span class="kw">break</span>;
  }
  <span class="kw">if</span> (s)
    <span class="kw">return</span> nboard;
  <span class="kw">else</span>
    <span class="kw">return</span> <span class="kw">null</span>;
}

<span class="kw">function</span> <span class="fu">moveAdd</span>(board, dir, neighbors) {
  <span class="kw">var</span> nboard = <span class="fu">move</span>(board, dir);
  <span class="kw">if</span> (nboard !== <span class="kw">null</span>) {
    <span class="ot">neighbors</span>.<span class="fu">push</span>(nboard);
  }
}

<span class="kw">function</span> <span class="fu">getNeighbors</span>(board) {
  <span class="kw">var</span> neighbors = [];
  <span class="fu">moveAdd</span>(board, up,    neighbors);
  <span class="fu">moveAdd</span>(board, down,  neighbors);
  <span class="fu">moveAdd</span>(board, right, neighbors);
  <span class="fu">moveAdd</span>(board, left,  neighbors);
  <span class="kw">return</span> neighbors;
}

<span class="kw">var</span> goal = [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>], 
            [<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">4</span>],
            [<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>]];

<span class="kw">var</span> start= [[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>], 
            [<span class="dv">8</span>,<span class="dv">2</span>,<span class="dv">5</span>],
            [<span class="dv">7</span>,<span class="dv">0</span>,<span class="dv">6</span>]];

<span class="kw">var</span> queue=[start];            <span class="co">// BFS 用的 queue, 起始點為 1。</span>
<span class="kw">var</span> visited={};
<span class="kw">var</span> parent={};
<span class="kw">var</span> level={};

<span class="kw">function</span> <span class="fu">bfs</span>(q, goal) { <span class="co">// 廣度優先搜尋</span>
  <span class="kw">while</span> (<span class="ot">q</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
    <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否則、取出 queue 的第一個節點。</span>
    <span class="kw">var</span> nodestr = <span class="fu">board2str</span>(node);
<span class="co">//  log(&quot;q.length=%d level=%d\n===node===\n%s==parent==\n%s&quot;, q.length, level[nodestr], nodestr, parent[nodestr]); // 印出節點</span>
    <span class="kw">if</span> (<span class="fu">equal</span>(node, goal)) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span> (visited[nodestr]===<span class="kw">undefined</span>)        <span class="co">// 如果該節點尚未拜訪過。</span>
      visited[nodestr] = <span class="kw">true</span>; <span class="co">//   標示為已拜訪</span>
    <span class="kw">else</span>                       <span class="co">// 否則 (已訪問過)</span>
      <span class="kw">continue</span>;                <span class="co">//   不繼續搜尋，直接返回。</span>
    <span class="kw">var</span> neighbors = <span class="fu">getNeighbors</span>(node); <span class="co">// 取出鄰居。</span>
    <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 對於每個鄰居</span>
      <span class="kw">var</span> n = neighbors[i];
      <span class="kw">var</span> nstr = <span class="fu">board2str</span>(n);
      <span class="kw">if</span> (!visited[nstr]) {    <span class="co">// 假如該鄰居還沒被拜訪過</span>
        parent[nstr] = nodestr;
    level[nstr] = level[nodestr] + <span class="dv">1</span>;
        <span class="fu">enqueue</span>(q, n);         <span class="co">//   就放入 queue 中</span>
      }
    }
  }
  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="kw">function</span> <span class="fu">backtrace</span>(goal) {
  <span class="fu">log</span>(<span class="st">&quot;======= backtrace =========&quot;</span>);
  <span class="kw">var</span> nodestr = <span class="fu">board2str</span>(goal);
  <span class="kw">while</span> (nodestr !== <span class="kw">undefined</span>) {
    <span class="fu">log</span>(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, nodestr);
    nodestr = parent[nodestr];
  }
}

level[<span class="fu">board2str</span>(start)]=<span class="dv">0</span>;
<span class="kw">var</span> found = <span class="fu">bfs</span>(queue, goal); <span class="co">// 呼叫廣度優先搜尋。</span>
<span class="fu">log</span>(<span class="st">&quot;bfs:found=%s&quot;</span>, found);
<span class="kw">if</span> (found)
  <span class="fu">backtrace</span>(goal);</code></pre>
<h3 id="執行結果-2"><a href="#執行結果-2">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node puzzleSearch.js
bfs:found=true
======= backtrace =========
1,2,3
8,0,4
7,6,5

1,0,3
8,2,4
7,6,5

1,3,0
8,2,4
7,6,5

1,3,4
8,2,0
7,6,5

1,3,4
8,2,5
7,6,0

1,3,4
8,2,5
7,0,6</code></pre>
<h3 id="結語-2"><a href="#結語-2">結語</a></h3>
<p>在上述執行結果中，我們是將盤面拼完後，才逆向追蹤印出移動過程，因此整個移動方法應該從最下面的盤面看起。換句話說，真正的順序如下：</p>
<pre><code>1,3,4    1,3,4    1,3,4     1,3,0    1,0,3    1,2,3
8,2,5 =&gt; 8,2,5 =&gt; 8,2,0 =&gt;  8,2,4 =&gt; 8,2,4 =&gt; 8,0,4
7,0,6    7,6,0    7,6,5     7,6,5    7,6,5    7,6,5</code></pre>
<p>從上面過程中，您可以看出我們的程式將打亂的盤面給拼回來了。</p>
<p>【本文由陳鍾誠取材並修改自 <a href="http://zh.wikipedia.org/">維基百科</a>，採用創作共用的 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 授權】</p>
<h1 id="程式人文集"><a href="#程式人文集">程式人文集</a></h1>
<h2 id="從-arduino-到-avr-晶片1----avr-晶片與-io-ports-範例-作者cooper-maa"><a href="#從-arduino-到-avr-晶片1----avr-晶片與-io-ports-範例-作者cooper-maa">從 Arduino 到 AVR 晶片(1) -- AVR 晶片與 IO ports 範例 (作者：Cooper Maa)</a></h2>
<h3 id="前言-3"><a href="#前言-3">前言</a></h3>
<p>單晶片微電腦 (Single Chip Microcomputer)，或稱微控制器 (Microcontroller，縮寫為 µC 或 MCU)，是一個將 CPU、記憶體、I/O Port 等周邊電路全部整合為一體的晶片。不像微處理器需要外部電路連接周邊，微控制器的應用只要少許的電路就可以運作，因為所有必要的周邊它都內建了。微控制器主要用在嵌入式系統，例如汽車電子、工業控制、機械控制等領域。</p>
<p>著名的 Arduino 板子上也有一顆微控制器，它是 AVR 的晶片，例如 Arduino UNO, Duemilanove 用的是 ATmega328，Arduino Diecimila 的是 ATmega168，而早期的 Arduino USB 則是使用 ATmega8。</p>
<p>Arduino 在歐美非常流行，因為它超簡單，很快就可以上手，我認為從 Arduino 到 AVR 是一條進入單晶片韌體開發的捷徑，因此著手撰寫這一系列的教學文件，希望這可以幫助想學單晶片韌體開發的新手，也希望能夠拋磚引玉，藉此引出高手發表佳文，同時也希望路過的先進不吝指教。</p>
<h4 id="教學目標"><a href="#教學目標">教學目標</a></h4>
<p>我假設讀者你是單晶片新手，我不打算一次把所有與單晶片有關的東西全塞到你腦袋裏，因為這麼做其實是揠苗助長，適得其反，因此這系列的教學將維持 Arduino 一貫的簡約風格，點到為止。這系列教學的目標為：</p>
<ul>
<li>帶你認識 AVR 單晶片以及其周邊，包括 I/O Ports, Interrupt, Timer, USART, PWM, ADC 等。</li>
</ul>
<h4 id="授課對象"><a href="#授課對象">授課對象</a></h4>
<p>你必須具備下列基礎:</p>
<ul>
<li>寫過 Arduino 程式 * 如果你沒接觸過 Arduino，建議你先看「 <a href="http://coopermaa2nd.blogspot.com/2011/05/arduino.html">Arduino 入門教學</a> 」。</li>
<li>熟悉 C 語言</li>
</ul>
<h4 id="上課器材"><a href="#上課器材">上課器材</a></h4>
<p>你需要一張 Arduino 板子，一條 USB 傳輸線，以及 Arduino IDE 軟體開發環境:</p>
<div class="figure">
<img src="../img/avr0.1.png" alt="▲ Arduino UNO 與 USB 傳輸線" /><p class="caption">▲ Arduino UNO 與 USB 傳輸線</p>
</div>
<div class="figure">
<img src="../img/avr0.2.png" alt="▲ Arduino IDE" /><p class="caption">▲ Arduino IDE</p>
</div>
<h3 id="avr-晶片簡介"><a href="#avr-晶片簡介">1. AVR 晶片簡介</a></h3>
<p>AVR 是 ATmel 這家公司設計的 8 位元晶片，晶片架構來自於 Alf-Egil Bogen 和 Vegard Wollan 的構想。AVR 是 Alf (Egil Bogen) and Vegard (Wollan) 's Risc processor 的縮寫。</p>
<p>AVR 目前大概可分為下列幾個家族:</p>
<p>8-bit tinyAVR 系列 8-bit megaAVR 系列 8/16-bit XMEGA 系列 32-bit AVRs 系列 排愈後面的等級愈高，主要是記憶體較大、速度較快、腳位和周邊也比較多。</p>
<p>如果沒有特別聲明，這系列教學中提到的 AVR 指的都是 8 位元的晶片。</p>
<h4 id="arduino-與-avr-晶片的關係"><a href="#arduino-與-avr-晶片的關係">Arduino 與 AVR 晶片的關係</a></h4>
<p>前面說過，Arduino 用的就是 AVR 的晶片，你可以在 Arduino 板子上找到 AVR 晶片，以 Arduino UNO 為例，晶片所在的位置如下圖所示:</p>
<div class="figure">
<img src="../img/avr1.png" alt="▲ Arduino UNO" /><p class="caption">▲ Arduino UNO</p>
</div>
<p>在 arduino.cc <a href="http://arduino.cc/en/Main/Hardware">這個頁面</a> 中，條列了 Arduino 各種版本的板子、硬體規格、所用的 MCU 等資訊。下列是幾款 Arduino 跟它們所用的 MCU 對照表:</p>
<ul>
<li>Arduino UNO: ATmega328</li>
<li>Arduino Duemilanove: ATmega328 (剛出道時使用 ATmega168)</li>
<li>Arduino Diecimila: ATmega168</li>
<li>Arduino Mega: ATmega1280</li>
<li>Arduino Mega 2560: ATmega2560</li>
<li>Arduino NG: ATmega168 (剛出道時使用 ATmega8)</li>
<li>Arduino USB: ATmega8</li>
<li>ATmega328 晶片的重要特性</li>
</ul>
<p>Arduino UNO 和 Duemilanove 用的是同一顆 ATmega328 晶片，下表是 ATmega328 的晶片特性摘要:</p>
<table>
<thead>
<tr class="header">
<th align="left">特性</th>
<th align="left">說明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Operating Voltage</td>
<td align="left">1.8V - 5V</td>
</tr>
<tr class="even">
<td align="left">Flash Memory</td>
<td align="left">32 KB</td>
</tr>
<tr class="odd">
<td align="left">SRAM</td>
<td align="left">2 KB</td>
</tr>
<tr class="even">
<td align="left">EEPROM</td>
<td align="left">1 KB</td>
</tr>
<tr class="odd">
<td align="left">Clock Speed</td>
<td align="left">16 MHz</td>
</tr>
<tr class="even">
<td align="left">External Interrupt</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">Timer</td>
<td align="left">Two 8-bit Timer/Counters with Prescaler and Compare Mode. One 16-bit Timer/Counter with Prescaler, Compare and Capture Mode</td>
</tr>
<tr class="even">
<td align="left">PWM Channel</td>
<td align="left">6 Channels</td>
</tr>
<tr class="odd">
<td align="left">ADC Channel</td>
<td align="left">8 Channels 10-bit ADC in TQFP package. 6 Channels 10-bit ADC in PDIP package</td>
</tr>
<tr class="even">
<td align="left">USART</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">SPI</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">TWI</td>
<td align="left">Phlilips I2C compatible</td>
</tr>
</tbody>
</table>
<p>如果你是第一次接觸單晶片，表中很多名詞你可能不認識。不用擔心，這張表你現在只要大概瀏覽一下即可，這些周邊之後會一個個介紹。</p>
<h4 id="atmega328-的晶片封裝ic-package"><a href="#atmega328-的晶片封裝ic-package">ATmega328 的晶片封裝(IC package)</a></h4>
<p>一般來說，晶片的封裝分成 PDIP 和 TQFP 兩種封裝。</p>
<p>註:</p>
<ul>
<li>PDIP 是 Plastic Dual Inline Package 的縮寫，指的是塑膠雙排針腳式封裝。</li>
<li>TQFP Thin Quad Flat Pack 的縮寫，指的是薄型方形扁平封裝。</li>
</ul>
<p>以 Arduino UNO 所用的 ATmega328 為例，它屬於 PDIP 封裝，其 I/O 腳位配置圖 (Pinout) 如下:</p>
<div class="figure">
<img src="../img/avr2.png" />
</div>
<p>而 ATmega328 TQFP 封裝的 I/O 腳位配置圖 (Pinout) 如下:</p>
<div class="figure">
<img src="../img/avr3.png" />
</div>
<h3 id="io-ports"><a href="#io-ports">2. I/O Ports</a></h3>
<p>Arduino 板子所用的晶片 (以 ATmega8 和 ATmega168/328 為例) 有三個 8-bit 的 PORTs :</p>
<ul>
<li>B: 對應 Arduino 的 digital pin 8 to 13</li>
<li>C: 對應 Arduino 的 analog input pin 0 to 5</li>
<li>D: 對應 Arduino 的 digital pins 0 to 7</li>
</ul>
<h4 id="arduino-與-avr-晶片腳位對應表"><a href="#arduino-與-avr-晶片腳位對應表">Arduino 與 AVR 晶片腳位對應表</a></h4>
<p>底下這張圖顯示 Arduino 跟 ATmega8 之間的腳位對應關係:</p>
<div class="figure">
<img src="../img/avr4.png" alt="▲ 圖片來源: arduino.cc" /><p class="caption">▲ 圖片來源: arduino.cc</p>
</div>
<p>例如，Arduino 的 pin 13 對應的腳位為 PB5。</p>
<p>而底下是 Arduino 跟 ATmega168 的腳位對應關係圖:</p>
<div class="figure">
<img src="../img/avr5.png" alt="▲ 圖片來源: arduino.cc" /><p class="caption">▲ 圖片來源: arduino.cc</p>
</div>
<p>Arduino UNO 和 Arduino Duemilanove 用的晶片都是 ATmega328，Arduino Diecimila 用的是 ATmega168，而早期的 Arduino USB 則是使用 ATmega8。</p>
<p>註: ATmega328 跟 ATmega168 的腳位配置 (Pinout) 是一模一樣的。</p>
<ul>
<li>2013/4/12 補充: 有個叫 Pighixxxx 的義大利人畫了很多 <a href="http://arduino.cc/forum/index.php/topic,146315.0.html">Arduino 的 pinout diagrams</a> ，搭配這些圖學習會更方便。</li>
</ul>
<div class="figure">
<img src="../img/avr6.png" />
</div>
<h4 id="io-ports-暫存器簡介"><a href="#io-ports-暫存器簡介">I/O Ports 暫存器簡介</a></h4>
<p>AVR 晶片每個 port 都受三個暫存器控制，分別是 (x 代表 B, C, D):</p>
<ul>
<li>DDRx 暫存器: 用來決定腳位是 INPUT 或 OUTPUT。</li>
<li>PORTx 暫存器: 用來控制腳位輸出訊號為 HIGH 或為 LOW</li>
<li>PINx 暫存器: 用來讀取腳位的輸入訊號</li>
</ul>
<h3 id="blink-part-1"><a href="#blink-part-1">2.1 Blink part 1</a></h3>
<h4 id="實驗目的"><a href="#實驗目的">實驗目的</a></h4>
<p>讓一顆燈號閃爍，每隔一秒切換一次燈號。</p>
<h4 id="材料"><a href="#材料">材料</a></h4>
<ul>
<li>Arduino 主板 x 1</li>
<li>LED x 1</li>
</ul>
<h4 id="接線"><a href="#接線">接線</a></h4>
<p>把 LED 接到 Arduino 板子上，LED 長腳 (陽極) 接到 pin13，短腳 (陰極) 接到 GND，如下圖：</p>
<div class="figure">
<img src="../img/avr7.png" />
</div>
<h4 id="程式碼"><a href="#程式碼">程式碼</a></h4>
<p>先來看 Arduino 版本的 Blink 程式:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co"> * Blink.pde: 讓一顆燈號閃爍，每隔一秒切換一次燈號</span>
<span class="co"> */</span>

<span class="dt">const</span> <span class="dt">int</span> ledPin =  <span class="dv">13</span>;         <span class="co">// LED pin</span>

<span class="dt">void</span> setup() {                
  pinMode(ledPin, OUTPUT);      <span class="co">// 把 ledPin 設置成 output pin </span>
}

<span class="dt">void</span> loop() {
  digitalWrite(ledPin, HIGH);   <span class="co">// 打開 LED 燈號 </span>
  delay(<span class="dv">1000</span>);                  <span class="co">// 延遲一秒鐘</span>
  digitalWrite(ledPin, LOW);    <span class="co">// 關閉 LED 燈號 </span>
  delay(<span class="dv">1000</span>);                  <span class="co">// 延遲一秒鐘</span>
}</code></pre>
<p>這是 Arduino 的入門程式，相信你應該很熟悉。</p>
<p>從 Arduino 與 AVR 腳位對應關係圖可知，PB5 就是 pin 13，所以現在我們可以改用 I/O Ports 暫存器重新改寫程式:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co"> * Blink.pde:  讓一顆燈號閃爍，每隔一秒切換一次燈號</span>
<span class="co"> * schematic:</span>
<span class="co"> *   Connect a LED on PB5 (Arduino pin 13)</span>
<span class="co"> */</span>

<span class="dt">void</span> setup()
{
  DDRB |= (<span class="dv">1</span> &lt;&lt; <span class="dv">5</span>);      <span class="co">// 把 PB5 設置成 output pin </span>
}

<span class="dt">void</span> loop()
{
  PORTB |= (<span class="dv">1</span> &lt;&lt; <span class="dv">5</span>);     <span class="co">// 打開 LED 燈號</span>
  delay(<span class="dv">1000</span>); 
  PORTB &amp;= ~(<span class="dv">1</span> &lt;&lt; <span class="dv">5</span>);    <span class="co">// 關閉 LED 燈號 </span>
  delay(<span class="dv">1000</span>);
}</code></pre>
<p>PB5 是 PortB 的 bit 5，所以我們用 (1 &lt;&lt; 5) 當作位元遮罩 (bit mask)。 要特別注意的是，在設定 DDRx 暫存器的時候，1 是代表 OUTPUT，而 0 是代表 INPUT。</p>
<h3 id="blink-part-2-用-_bv-巨集把程式變得清晰易讀"><a href="#blink-part-2-用-_bv-巨集把程式變得清晰易讀">2.2 Blink part 2 : 用 _BV() 巨集把程式變得清晰易讀</a></h3>
<p>前一篇的程式，如果用 _BV() 巨集改寫的話，會變得比較清晰易讀:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp">
<span class="co">/*</span>
<span class="co"> * BlinkWithBV.pde:  讓一顆燈號閃爍，每隔一秒切換一次燈號，使用 _BV() 巨集</span>
<span class="co"> * schematic:</span>
<span class="co"> *   Connect a LED on PB5 (Arduino pin 13)</span>
<span class="co"> */</span>

<span class="co">/* 在 avr-libc 中的 sfr_defs.h 有這樣的定義:</span>
<span class="co">#define _BV(bit) (1 &lt;&lt; (bit))</span>
<span class="co">*/</span>

<span class="dt">void</span> setup()
{
  DDRB |= _BV(<span class="dv">5</span>);      <span class="co">// 把 PB5 設置成 output pin</span>
}

<span class="dt">void</span> loop()
{
  PORTB |= _BV(<span class="dv">5</span>);     <span class="co">// 打開 LED 燈號</span>
  delay(<span class="dv">1000</span>); 
  PORTB &amp;= ~_BV(<span class="dv">5</span>);    <span class="co">// 關閉 LED 燈號</span>
  delay(<span class="dv">1000</span>);
}</code></pre>
<p>BV 是 Bit Value 的縮寫。_BV() 巨集的定義為:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp"><span class="ot">#define _BV(x) (1 &lt;&lt; x)</span></code></pre>
<p>所以 _BV(5) 就是 bit 5，由此我們馬上可以聯想到，DDRB |= _BV(5) 這行代表的是「把 PB5 這支腳位設置設 OUTPUT」(註: 1 是 OUTPUT，0 是 INPUT)。</p>
<h4 id="位元遮罩"><a href="#位元遮罩">位元遮罩</a></h4>
<p>我們可以把前面的程式稍微改良一下:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co"> * BlinkWithbitMask.pde: 讓一顆燈號閃爍&amp;#65292;每隔一秒切換一次燈號&amp;#65292;使用 _BV() 巨集</span>
<span class="co"> * schematic:</span>
<span class="co"> *   Connect a LED on PB5 (Arduino pin 13)</span>
<span class="co"> */</span>

<span class="co">/* 在 avr-libc 中的 sfr_defs.h 有這樣的定義:</span>
<span class="co">#define _BV(bit) (1 &lt;&lt; (bit))</span>
<span class="co">*/</span>

<span class="ot">#define bitMask _BV(5)  </span><span class="co">// bit mask of PB5</span>

<span class="dt">void</span> setup()
{
  DDRB |= bitMask;      <span class="co">// 把 PB5 設置成 output pin</span>
}

<span class="dt">void</span> loop()
{
  PORTB |= bitMask;     <span class="co">// 打開 LED 燈號</span>
  delay(<span class="dv">1000</span>); 
  PORTB &amp;= ~bitMask;    <span class="co">// 關閉 LED 燈號</span>
  delay(<span class="dv">1000</span>);
}</code></pre>
<p>利用 bit mask (位元遮罩) 的概念，把 _BV(5) 定義成 bitMask 巨集，這麼一來，當 LED 接到別支腳位，不再是 PB5 時，程式只需要調整 bitMask 巨集，其它地方都不用修改。</p>
<h4 id="arduino-腳位的位元遮罩對照表"><a href="#arduino-腳位的位元遮罩對照表">Arduino 腳位的位元遮罩對照表</a></h4>
<p>利用位元遮罩的概念，我們可以進一步這樣做:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp">
<span class="co">/*</span>
<span class="co"> * digitalPin_to_bitmask.pde:  </span>
<span class="co"> *  讓一顆燈號閃爍&amp;#65292;每隔一秒切換一次燈號&amp;#65292;使用 _BV() 巨集與位元遮罩 </span>
<span class="co"> * schematic:</span>
<span class="co"> *   Connect a LED on PB5 (Arduino pin 13)</span>
<span class="co"> */</span>

<span class="co">// bit masks of Arduino digital pins</span>
<span class="dt">const</span> byte digital_pin_to_bit_mask[] = {
    _BV(<span class="dv">0</span>), <span class="co">/* 0, port D */</span>
    _BV(<span class="dv">1</span>),
    _BV(<span class="dv">2</span>),
    _BV(<span class="dv">3</span>),
    _BV(<span class="dv">4</span>),
    _BV(<span class="dv">5</span>),
    _BV(<span class="dv">6</span>),
    _BV(<span class="dv">7</span>),
    _BV(<span class="dv">0</span>), <span class="co">/* 8, port B */</span>
    _BV(<span class="dv">1</span>),
    _BV(<span class="dv">2</span>),
    _BV(<span class="dv">3</span>),
    _BV(<span class="dv">4</span>),
    _BV(<span class="dv">5</span>),
    _BV(<span class="dv">0</span>), <span class="co">/* 14, port C */</span>
    _BV(<span class="dv">1</span>),
    _BV(<span class="dv">2</span>),
    _BV(<span class="dv">3</span>),
    _BV(<span class="dv">4</span>),
    _BV(<span class="dv">5</span>),
};

<span class="dt">const</span> <span class="dt">int</span> ledPin = <span class="dv">13</span>;   <span class="co">// PB5</span>
<span class="dt">const</span> byte bitMask = digital_pin_to_bit_mask[ledPin]; <span class="co">// will get _BV(5)</span>

<span class="dt">void</span> setup()
{
  DDRB |= bitMask;      <span class="co">// 把 PB5 設置成 output pin</span>
}

<span class="dt">void</span> loop()
{
  PORTB |= bitMask;     <span class="co">// 打開 LED 燈號</span>
  delay(<span class="dv">1000</span>); 
  PORTB &amp;= ~bitMask;    <span class="co">// 關閉 LED 燈號</span>
  delay(<span class="dv">1000</span>);
}</code></pre>
<p>在這個範例中，我們建了一個 Arduino digital pin 的位元遮罩對照表 digital_pin_to_bit_mask。我們知道， pin 13 就是 PB5，有了這張對照表，就可以很容易算出 pin 13 的位元遮罩，像這樣:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> ledPin = <span class="dv">13</span>;   <span class="co">// PB5</span>
<span class="dt">const</span> byte bitMask = digital_pin_to_bit_mask[ledPin]; <span class="co">// will get _BV(5)</span></code></pre>
<p>這會得到 _BV(5)，也就是 PB5 的位元遮罩，亦即 pin 13 的位元遮罩。</p>
<h4 id="動動腦"><a href="#動動腦">動動腦</a></h4>
<p>雖然上面的程式可以算出 Arduino digital pin 的位元遮罩，但是如果進一步思考會發現一個問題：因為 setup() 和 loop() 已經固定使用 PORTB，所以即便算出其它腳位的位元遮罩，比如座落在 PD2 的 pin 2 (位元遮罩是 _BV(2) )，到時真正受影響的卻還是 PB2。因此，如果你想控制 pin 2，除了改 ledPin 外，你還得修改 setup() 和 loop() 把其中的 DDRB 換成 DDRD，而 PORTB 換成 PORTD，這樣才行。</p>
<p>想想看，這個問題要怎麼解決才好呢?</p>
<h3 id="button"><a href="#button">2.3 Button</a></h3>
<h4 id="實驗目的-1"><a href="#實驗目的-1">實驗目的</a></h4>
<p>使用按鍵 (PushButton) 控制 LED，按鍵被按下時打開 LED，按鍵放開時關掉 LED。 材料</p>
<ul>
<li>Arduino 主板 x 1</li>
<li>LED x 1</li>
<li>Pushbutton x 1</li>
<li>10K 歐姆電阻 x 1</li>
<li>麵包板 x 1</li>
<li>單心線 x N</li>
</ul>
<h4 id="接線-1"><a href="#接線-1">接線</a></h4>
<p>把 LED 接到 pin 13，長腳 (陽極) 接到 pin 13，短腳 (陰極) 接到 GND 把 pushbutton 一支腳接到 +5V，另一支腳接到 pin 2 同時接一顆 10K 電阻連到 GND</p>
<div class="figure">
<img src="../img/avr8.png" />
</div>
<h4 id="程式碼-1"><a href="#程式碼-1">程式碼</a></h4>
<p>先來看 Arduino 版本的 Button 程式:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp">
<span class="co">/*</span>
<span class="co"> * Button.pde: 使用按鍵 (PushButton)控制 LED 燈號的開關</span>
<span class="co"> */</span>

<span class="dt">const</span> <span class="dt">int</span> buttonPin = <span class="dv">2</span>;                 <span class="co">// 按鈕(pushbutton)</span>
<span class="dt">const</span> <span class="dt">int</span> ledPin = <span class="dv">13</span>;                   <span class="co">// LED</span>

<span class="dt">int</span> buttonState;                         <span class="co">// 用來儲存按鈕狀態</span>

<span class="dt">void</span> setup() {
  pinMode(ledPin, OUTPUT);               <span class="co">// 把 ledPin 設置成 OUTPUT</span>
  pinMode(buttonPin, INPUT);             <span class="co">// 把 buttonPin 設置成 INPUT</span>
}

<span class="dt">void</span> loop(){
  <span class="co">// 讀取按鈕的狀態</span>
  buttonState = digitalRead(buttonPin);

  <span class="co">// 檢查按鈕是否被按下</span>
  <span class="co">// 是的話&amp;#65292;buttonState 會是 HIGH</span>
  <span class="kw">if</span> (buttonState == HIGH) {     
    digitalWrite(ledPin, HIGH);          <span class="co">// 打開 LED</span>
  } 
  <span class="kw">else</span> {
    digitalWrite(ledPin, LOW);           <span class="co">// 關閉 LED</span>
  }
}</code></pre>
<p>從腳位對應關係圖可知，PB5 就是 pin 13，而 PD2 就是 pin 2，所以現在我們可以改用 I/O Ports 暫存器重新改寫程式:</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp">
<span class="co">/*</span>
<span class="co"> * Button.pde: 使用按鍵 (PushButton)控制 LED 燈號的開關</span>
<span class="co"> * </span>
<span class="co"> * Pin map:</span>
<span class="co"> *  Arduino pin 13 = PB5</span>
<span class="co"> *  Arduino pin  2 = PD2 </span>
<span class="co"> */</span>

<span class="co">// 底下兩個常數程式沒有用到，只是當作參考 </span>
<span class="dt">const</span> <span class="dt">int</span> buttonPin = <span class="dv">2</span>;           <span class="co">// 按鈕(pushbutton)</span>
<span class="dt">const</span> <span class="dt">int</span> ledPin = <span class="dv">13</span>;             <span class="co">// LED</span>

<span class="ot">#define buttonPinBitMask  _BV(2)   </span><span class="co">// pin 2  = PD2</span>
<span class="ot">#define ledPinBitMask     _BV(5)   </span><span class="co">// pin 13 = PB5</span>

<span class="dt">int</span> buttonState;                   <span class="co">// 用來儲存按鈕狀態</span>

<span class="dt">void</span> setup()
{
  DDRB |= ledPinBitMask;           <span class="co">// 把 ledPin 設置成 OUTPUT</span>
  DDRD &amp;= ~buttonPinBitMask;       <span class="co">// 把 buttonPin 設置成 INPUT</span>
}

<span class="dt">void</span> loop()
{    
  <span class="co">// 讀取按鈕的狀態</span>
  <span class="kw">if</span> (PIND &amp; buttonPinBitMask) {
    buttonState = HIGH;
  } <span class="kw">else</span> {
    buttonState = LOW;     
  }

  <span class="co">// 檢查按鈕是否被按下</span>
  <span class="co">// 是的話&amp;#65292;buttonState 會是 HIGH  </span>
  <span class="kw">if</span> (buttonState == HIGH) {
    PORTB |= ledPinBitMask;         <span class="co">// 打開 LED</span>
  } <span class="kw">else</span> {
    PORTB &amp;= ~ledPinBitMask;        <span class="co">// 關閉 LED</span>
  }
}</code></pre>
<p>程式為 PD2 和 PB5 兩支腳位分別定義了 buttonPinBitMask 和 ledPinBitMask 兩個位元遮罩，利用這兩個位元遮罩進行位元運算，透過 DDRx 暫存器決定腳位是 INPUT 或 OUTPUT 模式，用 PINx 暫存器讀取按鈕的腳位狀態，然後用 PORTx 暫存器控制 led 腳位的輸出訊號。 _BV() 巨集我們在前面已經介紹過。</p>
<p>到此相信你對 AVR 晶片的 I/O Ports 應該已經有足夠的了解了。</p>
<h4 id="延伸閱讀"><a href="#延伸閱讀">延伸閱讀</a></h4>
<ul>
<li><a href="http://www.atmel.com/products/avr/default.asp?category_id=163&amp;family_id=607&amp;source=left_nav">ATmel 官網: AVR 8- and 32 bit</a></li>
<li><a href="http://www.atmel.com/dyn/resources/prod_documents/8271S.pdf">ATmega168/328 Datasheet</a></li>
<li><a href="http://en.wikipedia.org/wiki/Atmel_AVR">Wikipedia 百科全書: ATmel AVR</a></li>
<li><a href="http://www.arduino.cc/en/Reference/PortManipulation">Port Registers</a></li>
<li><a href="http://coopermaa2nd.blogspot.com/2010/12/arduino-lab1-blinking-led.html">Arduino 筆記 – Lab1 Blinking a LED</a></li>
<li><a href="http://feedproxy.google.com/~r/CooperMaa/~3/O55sTkSt7pA/bv.html">_BV 巨集介紹</a></li>
<li><a href="http://coopermaa2nd.blogspot.com/2010/12/arduino-lab2-led.html">Arduino 筆記 – Lab2 使用按鍵控制 LED 燈號</a></li>
</ul>
<p>【本文作者為馬萬圳，原文網址為： <a href="http://coopermaa2nd.blogspot.tw/2011/07/from-arduino-to-avr.html">http://coopermaa2nd.blogspot.tw/2011/07/from-arduino-to-avr.html</a> , <a href="http://coopermaa2nd.blogspot.tw/2011/07/1-avr.html">http://coopermaa2nd.blogspot.tw/2011/07/1-avr.html</a> , <a href="http://coopermaa2nd.blogspot.tw/2011/07/2-io-ports.html">http://coopermaa2nd.blogspot.tw/2011/07/2-io-ports.html</a> , <a href="http://coopermaa2nd.blogspot.tw/2011/04/21-blink-part-1.html">http://coopermaa2nd.blogspot.tw/2011/04/21-blink-part-1.html</a> , <a href="http://coopermaa2nd.blogspot.tw/2011/07/21-blink-part2.html">http://coopermaa2nd.blogspot.tw/2011/07/21-blink-part2.html</a> , <a href="http://coopermaa2nd.blogspot.tw/2011/07/22-button.html">http://coopermaa2nd.blogspot.tw/2011/07/22-button.html</a> ，由陳鍾誠編輯後納入本雜誌】</p>
<h2 id="符式協會論文文件編輯入門教學1-作業環境準備-作者鄧淵元"><a href="#符式協會論文文件編輯入門教學1-作業環境準備-作者鄧淵元">符式協會論文文件編輯入門教學(1) – 作業環境準備 (作者：鄧淵元)</a></h2>
<h3 id="論文文件編輯筆記---作業環境準備"><a href="#論文文件編輯筆記---作業環境準備">論文文件編輯筆記 - 作業環境準備</a></h3>
<h4 id="教學目的"><a href="#教學目的">教學目的</a></h4>
<p>減少協會成員、講員處理投稿文件的編輯時間，增進協會編輯相關論文。（待編輯）</p>
<h4 id="作業系統支援"><a href="#作業系統支援">作業系統支援</a></h4>
<ul>
<li>Windows 平台</li>
<li>OSX 平台</li>
<li>Linux 平台</li>
</ul>
<p>本入門篇將先以 Windows 作業系統為主要的教學平台，介紹相關的軟體安裝與設定。如果您需要 OSX 或 Linux 等作業系統的安裝說明，請再與臺灣符式推廣協會聯絡。</p>
<h4 id="基礎環境設定"><a href="#基礎環境設定">基礎環境設定</a></h4>
<p>請您預先檢查您的電腦是否已經安裝底下四種軟體，</p>
<ol style="list-style-type: decimal">
<li>解壓縮軟體: 7-zip(請注意有區分 32/64 位元版本), WinRAR, WinZip等，擇一即可。</li>
<li>輸入法： 新酷音輸入法, 或是您熟悉使用的輸入法均可。</li>
<li>文字編輯器： Notepad++, EMEditor, vim 等，擇一即可。</li>
<li>PDF瀏覽器： PDF Xchange Viewer(請注意有區分 32/64 位元版本)。</li>
</ol>
<p>如果還沒安裝，請先跳至附註說明，安裝相對應的軟體後，再繼續往「安裝協會論文出版相關軟體」處進行後續的步驟。</p>
<h4 id="安裝協會論文出版相關軟體"><a href="#安裝協會論文出版相關軟體">安裝協會論文出版相關軟體</a></h4>
<ol style="list-style-type: decimal">
<li>Dev C++: 文件轉檔將使用 makefile 來管理相關的輸入與輸出參數。</li>
<li>Pandoc： 主要的文件轉檔引擎。</li>
<li>Markdown 編輯器： MarkdownPad 2 Free。</li>
<li>Calibre：電子書管理工具，主要拿來轉 epub 與 pdf 格式使用。</li>
<li>MikTeX: Windows 平台 LaTeX 系統，能支援相關科學論文排版，數學方程式輸入等。</li>
<li>texmaker: 編輯 LaTex 格式文件。</li>
</ol>
<h4 id="dev-c"><a href="#dev-c">Dev C++</a></h4>
<p>請使用預設的安裝設定值安裝 Dev-C++ 即可，我們主要是要拿 MinGW 中的幾個程式來使用。</p>
<div class="figure">
<img src="../img/devcpp/DevCPP_install_01.png" />
</div>
<div class="figure">
<img src="../img/devcpp/DevCPP_install_02.png" />
</div>
<div class="figure">
<img src="../img/devcpp/DevCPP_install_03.png" />
</div>
<div class="figure">
<img src="../img/devcpp/DevCPP_install_04.png" />
</div>
<div class="figure">
<img src="../img/devcpp/DevCPP_install_05.png" />
</div>
<div class="figure">
<img src="../img/devcpp/DevCPP_install_06.png" />
</div>
<div class="figure">
<img src="../img/devcpp/DevCPP_install_07.png" />
</div>
<p>安裝完後，請檢查環境變數是否有加入</p>
<pre><code>c:\Dev-Cpp\bin</code></pre>
<p>這個環境變數，這樣才能搜尋得到 <strong>make.exe</strong> 與 <strong>MinGW</strong> 的相關執行檔。</p>
<div class="figure">
<img src="../img/devcpp/DevCPP_env_var_setting.png" />
</div>
<hr />
<h4 id="pandoc"><a href="#pandoc">Pandoc</a></h4>
<p>安裝 Windows 板的 pandoc 要注意，如果直接安裝，系統將會安裝在</p>
<ol style="list-style-type: decimal">
<li><p>WinXP <code>C:\Documents And Settings\USERNAME\Application Data\pandoc</code></p></li>
<li><p>Win7 <code>C:\Users\USERNAME\AppData\Roaming\pandoc</code></p></li>
</ol>
<p>這樣的路徑太長，我們不好使用與閱讀相關的設定文件。因此建議您開啟命令列視窗來安裝 Pandoc 。</p>
<pre><code>c:\&gt;msiexec /i pandoc-1.12.4.msi.windows.installer.msi allusers=1 applicationfolder=&quot;c:\pandoc&quot;</code></pre>
<div class="figure">
<img src="../img/pandoc/pandoc_install_00.png" />
</div>
<p>其餘就按照預設的安裝設定安裝即可。</p>
<div class="figure">
<img src="../img/pandoc/pandoc_install_01.png" />
</div>
<div class="figure">
<img src="../img/pandoc/pandoc_install_02.png" />
</div>
<div class="figure">
<img src="../img/pandoc/pandoc_install_03.png" />
</div>
<p>安裝完成後，應該會在 <strong>PATH</strong> 環境變數中加入</p>
<pre><code>c:\pandoc</code></pre>
<p>您可以在安裝目錄中查看 pandoc 的使用手冊。</p>
<div class="figure">
<img src="../img/pandoc/pandoc_install_04.png" />
</div>
<hr />
<h4 id="markdown-編輯器"><a href="#markdown-編輯器">Markdown 編輯器</a></h4>
<p>使用預設值安裝即可</p>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_02.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_03.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_04.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_05.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_06.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_07.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_08.png" />
</div>
<p>安裝過程中會需要裝 Visual C++ 2010 x86 可轉散發套件。</p>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_09.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_10.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_11.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_12.png" />
</div>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_13.png" />
</div>
<p>個人編輯是不需要升級到專業版。如果您認為好用，也可以贊助購買，鼓勵作者的辛勞。</p>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_14.png" />
</div>
<p>在 <strong>選項/編輯器/語言</strong> 處可以選擇「中文（中華民國）」。</p>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_15.png" />
</div>
<p>安裝完成後，您就可以編輯第一篇 Markdown 文件。</p>
<div class="figure">
<img src="../img/markdownpad2/markdownpad2_install_16.png" />
</div>
<hr />
<h4 id="calibre"><a href="#calibre">Calibre</a></h4>
<p>下載軟體的時候要特別注意，如果您是使用 32位元的系統，請下載 Windows 版本，如果是使用 64 位元的系統，請選擇下載 Windows 64 bit 版本。 <img src="../img/calibre/calibre_install_00.png" /></p>
<p>使用預設值安裝即可</p>
<div class="figure">
<img src="../img/calibre/calibre_install_01.png" />
</div>
<div class="figure">
<img src="../img/calibre/calibre_install_02.png" />
</div>
<div class="figure">
<img src="../img/calibre/calibre_install_03.png" />
</div>
<div class="figure">
<img src="../img/calibre/calibre_install_04.png" />
</div>
<p>軟體安裝後，不需要立即執行。</p>
<hr />
<h4 id="miktex"><a href="#miktex">MikTeX</a></h4>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Install_01.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Install_02.png" />
</div>
<p>請使用預設的安裝目錄即可</p>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Install_03.png" />
</div>
<p>請注意紙張是否設定為 <strong>A4</strong>，請不要設定成 <strong>letter</strong>。</p>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Install_04.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Install_05.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Install_06.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Install_07.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Install_08.png" />
</div>
<p>安裝完成</p>
<h5 id="miktex-套件更新與安裝"><a href="#miktex-套件更新與安裝">MikTeX 套件更新與安裝</a></h5>
<p>主要會用到 <strong>Setting(Admin)</strong> 和 <strong>update(Admin)</strong> 這兩個功能 <img src="../img/MikTeX/MikTeX_Setting_01.png" /></p>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_02.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_03.png" />
</div>
<p>請先從鏡像站中選出 <strong>http://shadow.ind.ntou.edu.tw</strong> ，然後準備更新相關套件。</p>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_04.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_05.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_06.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_07.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_08.png" />
</div>
<p>完成更新的工作，接著打開套件管理員Package Manager(Admin)，來安裝其餘的軟體。請在 keywords 輸入框中輸入<strong>xelatex</strong>，準備安裝相關的套件。</p>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_09.png" />
</div>
<div class="figure">
<img src="../img/MikTeX/MikTeX_Setting_10.png" />
</div>
<h4 id="texmaker"><a href="#texmaker">texmaker</a></h4>
<p>texmaker 主要的功能是編輯 LaTeX 文件，預設安裝，不經過設定是沒有辦法直接處理含有中文的文件，更別說要產出具有數學方程式且又要包含中文字的論文。因此我們要測試是否有辦法透過設定，讓 LaTeX 產生中文的 pdf 文件。</p>
<p>請使用預設的安裝目錄即可 <img src="../img/texmaker/texmaker_install_01.png" /></p>
<div class="figure">
<img src="../img/texmaker/texmaker_install_02.png" />
</div>
<div class="figure">
<img src="../img/texmaker/texmaker_install_03.png" />
</div>
<div class="figure">
<img src="../img/texmaker/texmaker_install_04.png" />
</div>
<h5 id="設定-texmaker"><a href="#設定-texmaker">設定 texmaker</a></h5>
<p>安裝完畢後，請啟動軟體，然後點選 <strong>選項/設定 Texmaker</strong>。</p>
<div class="figure">
<img src="../img/texmaker/texmaker_install_05.png" />
</div>
<p>過去要讓 LaTeX 系統能處理中文論文排版是相當複雜的安裝與設定工作，主要的問題除了版本眾多(要另外裝 cwTeX, chiTeX...等)，安裝中文字型也是一個很繁瑣的問題，更別說還要處理多國語言文字。自從 MiTeX 系統支援 UTF-8 編碼與 xeTeX 系統後，處理中文論文也就變得容易許多。只要設定幾個步驟，就能開始編輯支援中文的 LaTeX 文件。</p>
<p>先將 <strong>命令</strong> 設定的 <strong>LaTeX</strong> 指令改為</p>
<pre><code>xelatex -interaction=nonstopmod %.tex</code></pre>
<div class="figure">
<img src="../img/texmaker/texmaker_install_06.png" />
</div>
<p>PDF 文件檢視器請自行指定成您電腦中的 PDF Reader 。</p>
<div class="figure">
<img src="../img/texmaker/texmaker_install_07.png" />
</div>
<p>在 <strong>快速編譯</strong> 的設定，請點選 <strong>自訂</strong>，然後加入類似底下的設定指令</p>
<pre><code>xelatex -interaction=nonstopmod %.tex | &quot;c:/Program Files/Tracker Software/PDF Viewer/PDFXCview.exe&quot; %.pdf | bibtex %.aux | xdvi %.dvi</code></pre>
<div class="figure">
<img src="../img/texmaker/texmaker_install_08.png" />
</div>
<p>再來是設定 <strong>編輯器</strong> 中的 <strong>編輯器字型編碼</strong> 為 <strong>UTF-8</strong>，然後最好也勾選 <strong>顯示行號</strong>。這樣就完成初步的設定。</p>
<div class="figure">
<img src="../img/texmaker/texmaker_install_09.png" />
</div>
<p>不過在設定完成的過程當中，因為需要一些額外的套件，此時 MikTeX 系統的套件管理員會自動提示是否要安裝，請直接選擇 <strong>Install</strong> 安裝即可。</p>
<div class="figure">
<img src="../img/texmaker/texmaker_install_10.png" />
</div>
<div class="figure">
<img src="../img/texmaker/texmaker_install_11.png" />
</div>
<div class="figure">
<img src="../img/texmaker/texmaker_install_12.png" />
</div>
<div class="figure">
<img src="../img/texmaker/texmaker_install_13.png" />
</div>
<div class="figure">
<img src="../img/texmaker/texmaker_install_14.png" />
</div>
<div class="figure">
<img src="../img/texmaker/texmaker_install_15.png" />
</div>
<h5 id="編輯-latex-文件測試"><a href="#編輯-latex-文件測試">編輯 LaTeX 文件測試</a></h5>
<p>請用 <strong>texmaker</strong> 開啟一個檔案，然後輸入底下的測試文件</p>
<pre><code>\documentclass{article}

\usepackage{fontspec}    %加這個就可以設定字體
\usepackage{xeCJK}       %讓中英文字體分開設置
\setCJKmainfont{標楷體}   %設定中文為系統上的字型，而英文不去更動，使用原TeX字型
\XeTeXlinebreaklocale &quot;zh&quot;             %這兩行一定要加，中文才能自動換行
\XeTeXlinebreakskip = 0pt plus 1pt     %這兩行一定要加，中文才能自動換行
\title{社團法人臺灣符式推廣協會\\103年度年會論文集}
\author{陳爽}
\date{\color{green}中華民國103年6月7日} %設定日期

\begin{document}
\maketitle
社團法人臺灣符式推廣協會。

English Test. 插入中文字，看看如何？ I like Forth. 

要插入一段數學方程式$y=ax+b$也沒問題，當然也可以輸入一些複雜的方程組或是矩陣。

        \[
       x_{1}^{(k+1)} = \frac{1}{a_{11}}(b_{1} - \sum_{j &lt; 1}{a_{1j}x_{j}^{(k+1)}} - \sum_{j &gt; 1}{a_{1j}x_{j}^{(k)}})
       \]
        \[
       x_{2}^{(k+1)} = \frac{1}{a_{22}}(b_{2} - \sum_{j &lt; 2}{a_{2j}x_{j}^{(k+1)}} - \sum_{j &gt; 2}{a_{2j}x_{j}^{(k)}}) 
       \]
\end{document}
</code></pre>
<div class="figure">
<img src="../img/texmaker/texmaker_compile_01.png" />
</div>
<div class="figure">
<img src="../img/texmaker/texmaker_compile_02.png" />
</div>
<hr />
<ul>
<li>社團法人臺灣符式推廣協會 -- <a href="http://www.figtaiwan.org">http://www.figtaiwan.org</a></li>
</ul>
<h2 id="從-rs-232-偷電的方法-作者bridan"><a href="#從-rs-232-偷電的方法-作者bridan">從 RS-232 偷電的方法 (作者：Bridan)</a></h2>
<p><a href="https://zh.wikipedia.org/wiki/RS232">RS-232</a> 是一個很古老的通訊界面，寫 <a href="http://4rdp.blogspot.tw/2008/03/blog-post_24.html">韌體</a> 的工程師只要有弄過通訊，一定知道它，現在只剩桌上型電腦可以找到這樣的介面，今天就分享如何從電腦 RS-232 介面偷電。</p>
<div class="figure">
<img src="../img/RS-232%20power.jpg" />
</div>
<p>圖中所有二極體是 1N4148，所有電阻都是 1 kΩ，這電路只能提供小電源。</p>
<p>RS-232 雖然在電腦介面已經被 USB 取代，不過它的非同步通訊 <a href="https://zh.wikipedia.org/wiki/UART">UART</a> 仍被各類 MCU 保留，它只需 TX、RX 兩隻腳就可以傳送與接收，像 <a href="http://4rdp.blogspot.tw/search/label/LEGO%20MINDSTORMS%20NXT">NXT</a> 的藍芽模組就是利用 UART 與 MCU 通訊。</p>
<p>(本文來自「研發養成所」 Bridan 的網誌，原文網址為 <a href="http://4rdp.blogspot.tw/2014/01/rs-232-power.html">http://4rdp.blogspot.tw/2014/01/rs-232-power.html</a> ，由陳鍾誠編輯後納入程式人雜誌)</p>
<h2 id="visual-basic-6.0實作簡易小算盤-作者廖憲得-0xde"><a href="#visual-basic-6.0實作簡易小算盤-作者廖憲得-0xde">Visual Basic 6.0:實作簡易小算盤 (作者：廖憲得 0xde)</a></h2>
<div class="figure">
<img src="../img/vb1.jpg" />
</div>
<pre class="sourceCode MonoBasic"><code class="sourceCode monobasic"><span class="kw">Dim</span> NumberTemp, Temp, S
<span class="kw">Private</span> <span class="kw">Sub </span>Command1_Click(Index <span class="kw">As</span> <span class="dt">Integer</span>)
    <span class="kw">Select Case Command1(Index).Caption</span>
        Case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
            <span class="kw">If </span>Temp &lt;&gt; <span class="st">&quot;&quot;</span> <span class="kw">And</span> S <span class="kw">Then</span> S = <span class="kw">False</span>: Text1.Text = 0
            Text1.Text = Val(Text1.Text &amp; Command1(Index).Caption) <span class="co">&#39; 是數值就 And 完後 Val</span>
        Case <span class="st">&quot;+/-&quot;</span>
            Text1.Text = -Text1.Text <span class="co">&#39; * -1 等於 補負號</span>
        Case <span class="st">&quot;.&quot;</span>
            <span class="kw">If </span>InStr(Text1, <span class="st">&quot;.&quot;</span>) = 0 <span class="kw">Then</span> Text1.Text = Text1.Text &amp; <span class="st">&quot;.&quot;</span> <span class="co">&#39; 判斷沒有點的話在加一個點</span>
        Case <span class="st">&quot;Log&quot;</span>
            <span class="kw">If </span>Val(Text1.Text) &gt; 0 <span class="kw">Then</span> Text1.Text = Log(Val(Text1.Text)) / Log(10) <span class="co">&#39; VB6 的 Log 公式為 Log(數值) / Log(N) N = 底數</span>
        Case <span class="st">&quot;AC&quot;</span>
            Text1.Text = 0 <span class="co">&#39; 將顯示歸零</span>
            Temp = <span class="st">&quot;&quot;</span> <span class="co">&#39; 運算暫存清空</span>
        Case <span class="st">&quot;Sqr&quot;</span>
            Text1.Text = Sqr(Text1) <span class="co">&#39; 開根號的函數為 Sqr (數值)</span>
        Case <span class="st">&quot;1/x&quot;</span>
            Text1.Text = 1 / Text1.Text <span class="co">&#39; 倒數</span>
        Case <span class="st">&quot;N!&quot;</span>
            Text1.Text = N(Text1.Text) <span class="co">&#39; 呼叫階乘副程式</span>
        Case <span class="st">&quot;Int&quot;</span>
            Text1.Text = Int(Text1.Text)  <span class="co">&#39; 取整數</span>
        Case <span class="st">&quot;+&quot;</span>, <span class="st">&quot;-&quot;</span>, <span class="st">&quot;*&quot;</span>, <span class="st">&quot;/&quot;</span>, <span class="st">&quot;And&quot;</span>, <span class="st">&quot;Xor&quot;</span>, <span class="st">&quot;Or&quot;</span>, <span class="st">&quot;Not&quot;</span>
            S = <span class="kw">True</span>
            <span class="kw">If </span>Temp = <span class="st">&quot;&quot;</span> <span class="kw">Then</span> <span class="co">&#39; 當運算元為空時</span>
                Temp = Command1(Index).Caption <span class="co">&#39; 紀錄運算元</span>
                NumberTemp = Text1.Text <span class="co">&#39; 紀錄運算子</span>
            <span class="kw">Else</span>
                <span class="kw">Call</span> Change(Temp) <span class="co">&#39; 運算</span>
                Temp = Command1(Index).Caption <span class="co">&#39; 紀錄運算元</span>
                NumberTemp = Text1.Text <span class="co">&#39; 紀錄運算子</span>
            <span class="kw">End If</span>

        Case <span class="st">&quot;=&quot;</span>
                <span class="kw">Call</span> Change(Temp) <span class="co">&#39; 運算</span>
                NumberTemp = Text1.Text <span class="co">&#39; 紀錄運算子</span>
    <span class="kw">End Select</span>
<span class="kw">End Sub</span>

<span class="kw">Function </span>Change(N) <span class="co">&#39; 運算</span>
   <span class="kw">If </span>N &lt;&gt; <span class="st">&quot;&quot;</span> <span class="kw">Then</span>
        <span class="kw">Select Case N</span>
            Case <span class="st">&quot;+&quot;</span>
                Text1.Text = NumberTemp + Val(Text1.Text)
            Case <span class="st">&quot;-&quot;</span>
                Text1.Text = NumberTemp - Val(Text1.Text)
            Case <span class="st">&quot;*&quot;</span>
                Text1.Text = NumberTemp * Val(Text1.Text)
            Case <span class="st">&quot;/&quot;</span>
                Text1.Text = NumberTemp / Val(Text1.Text)
            Case <span class="st">&quot;Or&quot;</span>
                Text1.Text = NumberTemp <span class="kw">Or</span> Val(Text1.Text)
            Case <span class="st">&quot;And&quot;</span>
                Text1.Text = NumberTemp <span class="kw">And</span> Val(Text1.Text)
            Case <span class="st">&quot;Xor&quot;</span>
                Text1.Text = NumberTemp <span class="kw">Xor</span> Val(Text1.Text)
            Case <span class="st">&quot;Not&quot;</span>
                Text1.Text = <span class="kw">Not</span> NumberTemp
        <span class="kw">End Select</span>
    <span class="kw">End If</span>
<span class="kw">End Function</span>
<span class="kw">Function </span>N(Inp) <span class="co">&#39; 階乘副程式</span>
    <span class="kw">If </span>Inp = 1 <span class="kw">Then</span>
        N = 1
    <span class="kw">Else</span>
        N = Inp * N(Inp - 1)
    <span class="kw">End If</span>
<span class="kw">End Function</span></code></pre>
<ul>
<li>原始碼下載： <a href="http://files.dotblogs.com.tw/0xde/1311/2013117191823675.rar">實作簡易小算盤.rar</a></li>
</ul>
<p>【本文作者為「廖憲得」，原文網址為： <a href="http://www.dotblogs.com.tw/0xde/archive/2013/11/07/127248.aspx">http://www.dotblogs.com.tw/0xde/archive/2013/11/07/127248.aspx</a> ，由陳鍾誠編輯後納入本雜誌】</p>
<h1 id="雜誌訊息"><a href="#雜誌訊息">雜誌訊息</a></h1>
<h2 id="讀者訂閱"><a href="#讀者訂閱">讀者訂閱</a></h2>
<p>程式人雜誌是一個結合「開放原始碼與公益捐款活動」的雜誌，簡稱「開放公益雜誌」。開放公益雜誌本著「讀書做善事、寫書做公益」的精神，我們非常歡迎程式人認養專欄、或者捐出您的網誌，如果您願意成為本雜誌的專欄作家，請加入 <a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌社團</a> 一同共襄盛舉。</p>
<p>我們透過發行這本雜誌，希望讓大家可以讀到想讀的書，學到想學的技術，同時也讓寫作的朋友的作品能產生良好價值 – 那就是讓讀者根據雜誌的價值捐款給慈善團體。 讀雜誌做公益也不需要有壓力，您不需要每讀一本就急著去捐款，您可以讀了十本再捐，或者使用固定的月捐款方式，當成是雜誌訂閱費，或者是季捐款、一年捐一次等都 OK ! 甚至是單純當個讀者我們也都很歡迎！</p>
<p>本雜誌每期參考價：NT 50 元，如果您喜歡本雜誌，請將書款捐贈公益團體。例如可捐贈給「羅慧夫顱顏基金會 彰化銀行(009) 帳號：5234-01-41778-800」。(若匯款要加註可用「程式人雜誌」五個字)</p>
<h2 id="投稿須知"><a href="#投稿須知">投稿須知</a></h2>
<p><em>給專欄寫作者：</em> 做公益不需要有壓力。如果您願意撰寫專欄，您可以輕鬆的寫，如果當月的稿件出不來，我們會安排其他稿件上場。</p>
<p><em>給網誌捐贈者：</em> 如果您沒時間寫專欄或投稿，沒關係，只要將您的網誌以 [創作共用的「姓名標示、非商業性、相同方式分享」授權] 並通知我們，我們會自動從中選取需要的文章進行編輯，放入適當的雜誌當中出刊。</p>
<p><em>給文章投稿者：</em> 程式人雜誌非常歡迎您加入作者的行列，如果您想撰寫任何文章或投稿，請用 markdown 或 LibreOffice 編輯好您的稿件，並於每個月 25 日前投稿到<a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌社團</a> 的檔案區，我們會盡可能將稿件編入隔月1號出版程式人雜誌當中，也歡迎您到社團中與我們一同討論。</p>
<p>如果您要投稿給程式人雜誌，我們最希望的格式是採用 markdown 的格式撰寫，然後將所有檔按壓縮為 zip 上傳到社團檔案區給我們， 如您想學習 markdown 的撰寫出版方式，可以參考 <a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201304/htm/video1.html">看影片學 markdown 編輯出版流程</a> 一文。</p>
<p>如果您無法採用 markdown 的方式撰寫，也可以直接給我們您的稿件，像是 MS. Word 的 doc 檔或 LibreOffice 的 odt 檔都可以，我們 會將這些稿件改寫為 markdown 之後編入雜誌當中。</p>
<h2 id="參與編輯"><a href="#參與編輯">參與編輯</a></h2>
<p>您也可以擔任程式人雜誌的編輯，甚至創造一個全新的公益雜誌，我們誠摯的邀請您加入「開放公益出版」的行列，如果您想擔任編輯或創造新雜誌，也歡迎到 <a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌社團</a> 來與我們討論相關事宜。</p>
<h2 id="公益資訊"><a href="#公益資訊">公益資訊</a></h2>
<table>
<col width="22%" />
<col width="20%" />
<col width="28%" />
<col width="28%" />
<thead>
<tr class="header">
<th align="left">公益團體</th>
<th align="left">聯絡資訊</th>
<th align="left">服務對象</th>
<th align="left">捐款帳號</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">財團法人羅慧夫顱顏基金會</td>
<td align="left"><a href="http://www.nncf.org/">http://www.nncf.org/</a> <BR/> <script type="text/javascript">
<!--
h='&#110;&#110;&#x63;&#102;&#46;&#x6f;&#114;&#x67;';a='&#64;';n='&#108;&#x79;&#110;&#110;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#108;&#x79;&#110;&#110;&#32;&#x61;&#116;&#32;&#110;&#110;&#x63;&#102;&#32;&#100;&#x6f;&#116;&#32;&#x6f;&#114;&#x67;</noscript> <BR/> 02-27190408分機 232</td>
<td align="left">顱顏患者 (如唇顎裂、小耳症或其他罕見顱顏缺陷）</td>
<td align="left">銀行：009彰化銀行民生分行<BR/> 帳號：5234-01-41778-800</td>
</tr>
<tr class="even">
<td align="left">社團法人台灣省兒童少年成長協會</td>
<td align="left"><a href="http://www.cyga.org/">http://www.cyga.org/</a> <BR/> <script type="text/javascript">
<!--
h='&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#x63;&#x79;&#x67;&#x61;&#x39;&#x39;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x63;&#x79;&#x67;&#x61;&#x39;&#x39;&#32;&#x61;&#116;&#32;&#x67;&#x6d;&#x61;&#x69;&#108;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;</noscript> <BR/> 04-23058005</td>
<td align="left">單親、隔代教養.弱勢及一般家庭之兒童青少年</td>
<td align="left">銀行：新光銀行 <BR/> 戶名：台灣省兒童少年成長協會 <BR/> 帳號：103-0912-10-000212-0</td>
</tr>
</tbody>
</table>
</div>
<div id="footer">
<a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌</a> ，採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> 授權，歡迎加入 <a href="https://www.facebook.com/groups/programmerMagazine/">雜誌社團</a>
</div>
</body>
</html>
